
# LeetCode第四题 两个排序数组的中位数

有两个大小为 m 和 n 的排序数组 nums1 和 nums2 。  
请找出两个排序数组的中位数并且总的运行时间复杂度为 O(log (m+n)) 。  
示例 1:  
> nums1 = [1, 3]  
> nums2 = [2]  
  
> 中位数是 2.0  
 
> 示例 2:  
> nums1 = [1, 2]  
> nums2 = [3, 4]  

> 中位数是 (2 + 3)/2 = 2.5  

## 解题思路
对于这道题，难点在于运行时间复杂度，使用排序算法，将两个数值合并排序，在选出中位数的方法，显然不符合时间复杂度的要求，因此，我们参考了[网址](https://leetcode.com/articles/median-of-two-sorted-arrays/)中的解题方法，时间复杂度符合要求。
## Java
```
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
		int m = nums1.length, n = nums2.length;
		if (m > n)
			return findMedianSortedArrays(nums2, nums1);/// 保证m<=n
		int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2;
		while (iMin <= iMax) {
			int i = (iMax + iMin) / 2;
			int j = halfLen - i;
			if (i < m && j > 0 && nums2[j - 1] > nums1[i]) {
				iMin = iMin + 1;
			} else if (i > 0 && j < n && nums1[i - 1] > nums2[j]) {
				iMax = iMax - 1;
			} else {
				double maxLeft = 0;
				if (i == 0) {
					maxLeft = nums2[j - 1];
				} else if (j == 0) {
					maxLeft = nums1[i - 1];
				} else {
					maxLeft = Math.max(nums1[i - 1], nums2[j - 1]);
				}
				if ((m + n) % 2 == 1)
					return maxLeft;
				double minRight = 0;
				if (i == m) {
					minRight = nums2[j];
				} else if (j == n) {
					minRight = nums1[i];
				} else {
					minRight = Math.min(nums1[i], nums2[j]);
				}
				return (maxLeft + minRight) / 2.0;
			}
		}
		return 0.0;
	}
```
## Python
```
class Solution(object):
    def findMedianSortedArrays(self, A, B):
        m, n = len(A), len(B)
        if (m > n):
            return Solution().findMedianSortedArrays(B, A)
        iMin, iMax, halfLen = 0, m, int((m + n + 1) / 2)
        while iMin <= iMax:
            i = int((iMax + iMin) / 2)
            j = int(halfLen - i)
            if i < m and j > 0 and B[j - 1] > A[i]:
                iMin = iMin + 1
            elif i > 0 and j < n and A[i - 1] > B[j]:
                iMax = iMax - 1
            else:
                if i == 0:
                    maxLeft = B[j - 1]
                elif j == 0:
                    maxLeft = A[i - 1]
                else:
                    maxLeft = max(A[i - 1], B[j - 1])
                if (m + n) % 2 == 1:
                    return maxLeft

                if i == m:
                    minRight = B[j]
                elif j == n:
                    minRight = A[i]
                else:
                    minRight = min(A[i], B[j])
                return (maxLeft + minRight) / 2.0
```
## C++ 
```

class Solution
{
public:
    double findMedianSortedArrays(vector<int>& A, vector<int>& B)
    {
        int m = A.size(), n = B.size();
        if(m>n)return findMedianSortedArrays(B, A);
        int iMin = 0, iMax = m, halfLen = (m+n+1)/2;
        while(iMin<=iMax)
        {
            int i = (iMin+iMax)/2;
            int j = halfLen - i;
            if(i<m&&j>0&& B[j-1]>A[i])
            {
                iMin = iMin + 1;
            }
            else if(i>0&&j<n&&A[i-1]>B[j])
            {
                iMax = iMax - 1;
            }
            else
            {
                double maxLeft = 0;
                if(i==0)
                {
                    maxLeft=B[j-1];
                }
                else if(j==0)
                {
                    maxLeft=A[i-1];
                }
                else
                {
                    maxLeft=max(A[i-1],B[j-1]);
                }
                if((m+n)%2==1)return maxLeft;

                double minRight = 0;
                if(i==m)
                {
                    minRight = B[j];
                }
                else if(j==n)
                {
                    minRight=A[i];
                }
                else
                {
                    minRight = min(A[i],B[j]);
                }
                return (maxLeft+minRight)/2.0;
            }
        }
        return 0.0;
    }
};
```
